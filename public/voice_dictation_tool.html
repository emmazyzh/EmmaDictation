<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Dictation Practice Tool</title>
  <style>
    body { font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial,"Noto Sans","PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif; text-align: center; padding: 2em; position: relative; overflow-x: hidden; background: #ffffff; color:#0f172a; }
    textarea { width: 80%; height: 100px; font-size: 1em; padding: 0.5em; margin: 2em 0; background:#fff; border:1px solid #e5e7eb; border-radius:10px; }
    #status { margin-top: 1em; font-size: 0.8em; color: #6b7280; }
    .icon-btn { font-size: 1em; padding: 0.7em 1.5em; margin: 0.3em; border: none; border-radius: 8px; cursor: pointer; background-color: #2563eb; color: #fff; box-shadow: 0 1px 2px rgba(15,23,42,.08); transition: transform .06s ease, filter .12s ease; }
    .icon-btn:hover { filter: brightness(1.05); }
    .icon-btn:active { transform: translateY(1px) scale(.98); }
    .voice-toggle { position: absolute; right: 10%; top: 2em; text-align: right; }
    #voiceSelect { padding: 0.5em; font-size: 1em; border:1px solid #e5e7eb; border-radius:8px; background:#fff; }
    #progress { margin-top: 1em; font-size: 0.8em; color:#6b7280; }
    #ribbons { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: 9999; background: url('https://www.gifcen.com/wp-content/uploads/2022/06/confetti-gif-3.gif') repeat; background-size: auto; }
    #wordDisplay { font-weight: bold; font-size: 1.2em; margin: 1em 0; }
    .eye-btn { background: none; border: none; cursor: pointer; font-size: 1.2em; margin-left: 0.5em; }
    #hintContainer { margin-top: 1em; width: 80%; margin-left: auto; margin-right: auto; text-align: left; }
    #hintTitle { font-weight: bold; margin-bottom: 0.5em; font-size: 1em; }
    #hintBox { border: 1px solid #e5e7eb; padding: 1em; border-radius: 12px; background: #f9fafb; white-space: pre-wrap; font-size: 14px;}
    select[multiple], select[size] { width: 100%; padding: 0.5em; background:#fff; border:1px solid #e5e7eb; border-radius:10px; }
    .tags-section { margin: 32px auto 40px; width:80%; }
    .tags-title { font-size: 16px; margin: 0 0 10px; color: #6b7280; }
    .tags-wrap { display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
    .tag { display: inline-block; padding: 6px 12px; border-radius: 999px; border: 1px solid #e5e7eb; background: #f3f4f6; color: #0f172a; font-size: 14px; transition: transform .08s ease, box-shadow .15s ease, background .15s ease; }
    .tag:hover { transform: translateY(-1px); box-shadow: 0 2px 6px rgba(0,0,0,.06); }
    .tag.active { background: #e0ecff; border-color: #3b82f6; outline: 2px solid #93c5fd; transform: scale(1.03); }
    /* 分段开关容器 */
    .mode-group{
      display: inline-flex;
      gap: 6px;
      padding: 6px;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      background: #f3f4f6;
    }

    /* 隐藏原生 radio，但保留可访问性（键盘可聚焦、屏幕阅读器可读） */
    .mode-group label > input[type="radio"]{
      position: absolute !important;
      clip: rect(1px,1px,1px,1px);
      clip-path: inset(50%);
      width: 1px; height: 1px;
      overflow: hidden; white-space: nowrap;
    }

    /* 标签当按钮用 */
    .mode-group label{
      position: relative;
      cursor: pointer;
      padding: 8px 14px;
      border-radius: 10px;
      font-size: 14px;
      font-weight: 600;
      color: #374151;
      user-select: none;
      transition: background .15s ease, color .15s ease, box-shadow .2s ease, transform .06s ease;
    }
    .mode-group label:hover{ background: #eef2ff; }

    /* 选中态（利用 :has 选择包含已选 radio 的 label） */
    .mode-group label:has(input:checked){
      background: #ffffff;
      color: #111827;
      box-shadow: 0 1px 2px rgba(0,0,0,.06);
    }

    /* 键盘可视焦点 */
    .mode-group label:has(input:focus-visible){
      outline: 2px solid #93c5fd;
      outline-offset: 2px;
    }

    /* --- Responsive: layout tokens --- */
    :root{
      --page-max: 960px;
      --panel-max: 900px; 
      --pad-x: clamp(12px, 4vw, 24px);
      --gap: clamp(8px, 2.5vw, 16px);
      --section-to-controls-gap: clamp(16px, 4vw, 36px);
    }

    /* Page container */
    .container{
      max-width: var(--page-max);
      margin: 0 auto;
      padding: 0 var(--pad-x);
      text-align: center;
    }

    /* Better base typography for mixed screens */
    h1{ 
      font-size: clamp(1.25rem, 2.2vw + 1rem, 2rem);
      margin: 0 0 .25em;
    }
    body{ 
      font-size: clamp(14px, 1.5vw, 16px);
    }

    /* Toolbar: mode pills + voice select in one row (wraps on small screens) */
    .toolbar{
      display: flex;
      align-items: center;
      justify-content: center;
      gap: var(--gap);
      flex-wrap: wrap;
      margin: 0 auto 1rem;
    }

    /* voice-toggle no longer absolute; let it flow */
    .voice-toggle{
      position: static;
    }

    /* Inputs & content blocks go full-width inside container */
    textarea,
    #hintContainer,
    .tags-section{
      width: 100%;
      margin-left: auto;
      margin-right: auto;
    }

    /* Make textarea height adaptive but not tiny */
    textarea{
      height: clamp(120px, 22vh, 200px);
    }

    /* Hint box readable on phones */
    #hintBox{
      font-size: clamp(13px, 1.6vw, 14px);
    }

    /* Word “tags” wrap nicely and are tappable on mobile */
    .tags-wrap{ gap: 10px; }
    .tag{
      font-size: clamp(12px, 2.5vw, 14px);
      padding: .5em .9em;
    }

    /* Controls: buttons become a neat grid on wider screens */
    .controls{
      display: grid;
      grid-template-columns: 1fr;
      gap: var(--gap);
      max-width: 720px;
      margin: 0 auto var(--gap);
    }
    .icon-btn{ width: 100%; }

    /* Show answer line with comfy size */
    #wordDisplay{
      font-size: clamp(1rem, 2.5vw, 1.2rem);
    }
    .eye-btn{
      font-size: clamp(1rem, 4vw, 1.2rem);
    }

    /* Book area: stack selects on phones, side-by-side on tablets/desktops */
    #bookSection{
      display: grid;
      grid-template-columns: repeat(2, minmax(280px, 1fr)); /* 两列，列宽不小于280px */
      gap: 12px;

      /* 关键：限制整体宽度并用 auto 外边距水平居中 */
      max-width: 900px;               /* 可按需调大/调小 */
      margin-left: auto;
      margin-right: auto;
      width: 100%;                    /* 在小屏占满容器 */
    }

    /* Replace fixed 40% width selects with fluid sizing */
    select[multiple], select[size]{
      width: 100%;
      height: clamp(140px, 38vh, 320px);
    }

    /* Mode pills: keep your visual style but make spacing adaptive */
    .mode-group{
      display: flex;
      width: fit-content;
      margin: 0 auto;
      gap: 6px;
      padding: 6px;
      border: 1px solid #e5e7eb;
      border-radius: 12px;
      background: #f3f4f6;
    }

    /* On wider screens, enhance layout */
    @media (min-width: 640px){
      .controls{ grid-template-columns: repeat(2, minmax(0,1fr)); }
    }
    @media (min-width: 900px){
      .controls{ grid-template-columns: repeat(4, minmax(0,1fr)); }
      #bookSection{ grid-template-columns: 1fr 1fr; }
    }

    /* Keep confetti overlay mobile-friendly */
    #ribbons{
      background-size: 240px auto; /* not huge on phones */
    }

    /* OPTIONAL: if long words overflow, allow breaks */
    #wordTags, #hintBox { overflow-wrap: anywhere; }
    .hidden { display: none !important; }


    /* 统一面板高度（可按需改数值） */
    #bookSection,
    #customSection{
      width: 100%;
      max-width: var(--panel-max);
      --panel-h: clamp(220px, 38vh, 420px); /* 手机不至于太小，PC也不会太高 */
      min-height: var(--panel-h);
      margin-bottom: var(--section-to-controls-gap);
    }

    /* Book：两列选择框且拉伸至同高 */
    #bookSection{
      display: grid;
      grid-template-columns: repeat(2, minmax(280px, 1fr)); /* 两列，列宽不小于280px */
      gap: 12px;

      /* 关键：限制整体宽度并用 auto 外边距水平居中 */
      max-width: 900px;               /* 可按需调大/调小 */
      margin-left: auto;
      margin-right: auto;
      width: 100%;                    /* 在小屏占满容器 */
    }

    /* 覆盖旧规则：选择框高度占满父容器 */
    #bookSection select{
      width: 100% !important;
      max-width: 100%;
      height: 100% !important; /* 防止先前 height:118px 等规则干扰 */
      min-height: 0;
    }

    /* Custom：让 textarea 占满父容器高度（而不是固定 100px） */
    #customSection{
      display: grid;           /* 让里面的 textarea 能用 height:100% */
    }
    #customSection textarea{
      width: 100% !important;   /* 覆盖全局 textarea 80% 规则 */
      max-width: 100%;
      height: 100% !important; /* 填满 #customSection 的最小高度 */
      margin: 0;               /* 避免外边距把整体高度“撑高” */
      width: 100%;
      box-sizing: border-box;  /* 计算高度时包含内边距 */
    }

    /* 小屏下 Book 面板改为单列，但仍保持同高 */
    @media (max-width: 900px){
      #bookSection{ grid-template-columns: 1fr; }
    }


  </style>

  <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

  
</head>
<body>
  <div class="container">
    <h1>Dictation Tool</h1>
    <div class="toolbar">
      <div class="mode-group">
        <label><input type="radio" name="mode" value="book"> Choose a Book</label>
        <label><input type="radio" name="mode" value="custom" checked> Customize Your Own Vocabulary List</label>
      </div>

      <!--div class="voice-toggle">
        <label for="voiceSelect">Voice:</label>
        <select id="voiceSelect">
          <option value="Tom">Tom</option>
          <option value="Evan">Evan</option>
          <option value="Samantha">Samantha</option>
          <option value="Zoe">Zoe</option>
        </select>
      </！div-->
    </div>
    <div id="bookSection" class="hidden">
      <select id="bookSelect" size="10"></select>
      <select id="sheetSelect" size="10"></select>
    </div>

    <div id="customSection">
      <textarea id="wordInput" placeholder="e.g., apple, banana, chocolate"></textarea>
    </div>
    <div class="controls">
      <button id="startBtn" class="icon-btn">Start</button>
      <button onclick="nextWord()" class="icon-btn">Next</button>
      <!--button onclick="playPreviousWord()" class="icon-btn">Last</!--button-->
      <button onclick="repeatCurrentWord()" class="icon-btn">Repeat</button>
      <button id="hintBtn" onclick="toggleHint()" class="icon-btn">Show Hint</button>
    </div>

    <div id="wordDisplay">Answer Key: *** <button class="eye-btn" onclick="toggleWord()">👁️</button></div>
    <p><span id="progress"></span>&nbsp;&nbsp;&nbsp;<span id="status">Status: Waiting for input...</span></p>

    <div id="hintContainer">
      <div id="hintTitle">Hints:</div>
      <div id="hintBox">Click the Show Hint button to reveal a hint for the current word.</div>
    </div>
    <section id="word-tags-section" class="tags-section">
        <div id="wordTags" class="tags-wrap"></div>
    </section>
  </div>

  <div id="ribbons"></div>

  <script>
    const books = {
      "BJU Science": "http://localhost:3000/download?id=1w12b1K3riu1T_ksH6OH_D2zCHr1bitTM"
    };

    let words = [], index = 0, voices = [], selectedVoice = null, isDictating = false, wentBack = false, showRealWord = false, hintsVisible = false;
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;          // 复用同一个实例
    let recognitionActive = false;   // 是否处于onstart~onend之间
    let listenRetryTimer = null;     // 重试定时器

    document.querySelectorAll('input[name="mode"]').forEach(r => {
      r.addEventListener('change', (e) => {
        if (e.target.value === 'book') {
          resetUI({ clearInput: true, clearSelectors: true });
          document.getElementById('bookSection').classList.remove('hidden');
          document.getElementById('customSection').classList.add('hidden');
          document.getElementById('bookSelect').selectedIndex = 0;
          document.getElementById('bookSelect').dispatchEvent(new Event('change'));
        } else {
          resetUI({ clearInput: true, clearSelectors: true });
          document.getElementById('customSection').classList.remove('hidden');
          document.getElementById('bookSection').classList.add('hidden');
        }
      });
    });

    window.onload = () => {
      const bookSelect = document.getElementById('bookSelect');
      for (const bookName in books) {
        const opt = document.createElement('option');
        opt.value = bookName;
        opt.textContent = bookName;
        bookSelect.appendChild(opt);
      }
      bookSelect.selectedIndex = 0;
    };

    document.getElementById('bookSelect').addEventListener('change', async () => {
      const url = books[document.getElementById('bookSelect').value];
      try {
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
        const sheetSelect = document.getElementById('sheetSelect');
        sheetSelect.innerHTML = '';

        const displayMap = workbook.SheetNames.map(name => {
          const trimmed = name.trim();
          const match = trimmed.match(/^(\d+)-(\d+)$/);
          const display = match ? `Grade ${match[1]} Unit ${match[2]}` : trimmed;
          return { value: name, label: display };
        }).sort((a, b) => a.label.localeCompare(b.label));

        displayMap.forEach(({ value, label }) => {
          const opt = document.createElement('option');
          opt.value = value;
          opt.textContent = label;
          sheetSelect.appendChild(opt);
        });

        sheetSelect.selectedIndex = 0;
        await preloadSheetWords();
      } catch (error) {
        console.error('Error loading workbook:', error);
      }
    });

    document.getElementById('sheetSelect').addEventListener('change', preloadSheetWords);

    async function preloadSheetWords() {
      const bookName = document.getElementById('bookSelect').value;
      const sheetSelect = document.getElementById('sheetSelect');
      const sheetName = sheetSelect.value;
      const selectedText = sheetSelect.options[sheetSelect.selectedIndex].textContent;
      const url = books[bookName];
      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      const workbook = XLSX.read(arrayBuffer, { type: 'array' });
      const sheet = workbook.Sheets[sheetName];
      const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      words = data.slice(1).map(row => row[1]).filter(Boolean);
      index = 0;
      updateProgress();
      renderWordTags(words);
      document.getElementById('status').textContent = `${selectedText}: ${words.length} words loaded. Ready to start.`;
    }

    function populateVoices() {
      voices = speechSynthesis.getVoices();
      const defaultVoiceName = document.getElementById('voiceSelect').value;
      selectedVoice = voices.find(v => v.name === defaultVoiceName) || voices[0];
    }

    speechSynthesis.onvoiceschanged = populateVoices;

    document.getElementById('voiceSelect').addEventListener('change', () => {
      const voiceName = document.getElementById('voiceSelect').value;
      selectedVoice = voices.find(v => v.name === voiceName) || voices[0];
    });

    function speakText(text) {
      // 播报前：若正在听，则先停（不会触发致命错误）
      if (recognition && recognitionActive) {
        try { recognition.stop(); } catch {}
      }

      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'en-US';
      // u.voice = selectedVoice; // 若你有自定义声音
      u.onend = () => {
        // 说完再进监听，避免自说自听造成 aborted
        listenNextCommand();
      };
      speechSynthesis.speak(u);
    }

    function updateProgress() {
      document.getElementById('progress').textContent = `Progress: ${Math.min(index, words.length)} / ${words.length}`;
    }



    function showRibbons() {
      console.log("showRibbons triggered");
      const ribbonDiv = document.getElementById('ribbons');
      ribbonDiv.style.display = 'block';
      setTimeout(() => {
      ribbonDiv.style.display = 'none';
      }, 5000);
    }


    function listenNextCommand() {
      if (!SR) {
        document.getElementById('status').textContent =
          'SpeechRecognition not supported in this browser.';
        return;
      }

      // 初始化 & 仅绑定一次事件
      if (!recognition) {
        recognition = new SR();
        recognition.lang = 'en-US';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;

        recognition.onstart = () => { recognitionActive = true; };
        recognition.onend   = () => { recognitionActive = false; };

        recognition.onresult = (event) => {
          const transcript = (event.results?.[0]?.[0]?.transcript || '')
            .toLowerCase();
          document.getElementById('status').textContent = `Heard: "${transcript}"`;

          if (transcript.includes("next") || transcript.includes("move on")
              || transcript.includes("done") || transcript.includes("finished")
              || transcript.includes("completed")) {

            if (index >= words.length) {
              // 可选：说话前停止麦克风，避免自说自听
              if (recognitionActive) { try { recognition.stop(); } catch {} }
              speakText('Great job! You finished the dictation! See you next time.');
              document.getElementById('status').textContent =
                'Great job! You finished the dictation! See you next time.';
              showRibbons();
              return;
            }
            nextWord(); // 建议在 nextWord 的播报结束后再调用 listenNextCommand()
            return;

          } else if (transcript.includes("again") || transcript.includes("repeat")
                    || transcript.includes("pardon")) {
            repeatCurrentWord(); // 同上，播报结束后再进入监听
            return;

          } else if (transcript.includes("last") || transcript.includes("previous")
                    || transcript.includes("back")) {
            playPreviousWord(); // 同上
            return;
          }

          // 未识别到命令：稍后再听一次（避免立刻 start 导致竞争）
          scheduleStart(180);
        };

        recognition.onerror = (event) => {
          const err = String(event?.error || '').toLowerCase();
          // "aborted" 多为非致命（stop/切换导致），忽略即可
          if (err !== 'aborted') {
            document.getElementById('status').textContent = `Error: ${event.error}`;
          }
          // 若仍需继续听命令，稍后再尝试启动
          scheduleStart(220);
        };
      }

      // 安全地启动识别：不在TTS说话时、不在已激活时
      scheduleStart(0);

      function scheduleStart(delayMs) {
        clearTimeout(listenRetryTimer);
        listenRetryTimer = setTimeout(() => {
          // TTS 在说话就延后
          if (speechSynthesis.speaking) { scheduleStart(150); return; }
          // 已在监听中就不重复 start
          if (recognitionActive) return;
          try {
            recognition.start();
          } catch (e) {
            // 可能是 invalid_state：再等一下重试
            scheduleStart(200);
          }
        }, delayMs);
      }
    }

    function repeatCurrentWord() {
      if (index > 0 && index <= words.length) {
        setActiveTag(index - 1);           // keep highlight on the same word
        speakText(words[index - 1]);
      }
      setTimeout(() => listenNextCommand(), 1000);
    }

    function playPreviousWord() {
      if (index <= 1 || wentBack) { listenNextCommand(); return; }
      index -= 2; wentBack = true; nextWord();
    }

    function nextWord() {
      if (!isDictating) return;
      if (index < words.length) {
        wentBack = false;
        document.getElementById('status').textContent = ``;

        // highlight the tag for the word we're about to speak
        setActiveTag(index);

        const currentWord = words[index++];
        speakText(currentWord);
        updateProgress();
        updateWordDisplay();
        showHint();
        setTimeout(() => listenNextCommand(), 1000);
      } else {
        document.getElementById('status').textContent = 'Great job! You finished the dictation! See you next time.';
        speakText('Great job! You finished the dictation! See you next time.');
        showRibbons(); updateProgress(); isDictating = false;
      }
    }


    function startDictation() {
      const mode = document.querySelector('input[name="mode"]:checked').value;
      if (mode === 'custom') {
        words = document.getElementById('wordInput').value.split(/\r?\n|,/).map(w => w.trim()).filter(Boolean);
      }
      const voiceName = document.getElementById('voiceSelect').value;
      selectedVoice = voices.find(v => v.name === voiceName) || voices[0];
      index = 0; wentBack = false;
      if (words.length === 0) {
        document.getElementById('status').textContent = 'Please enter or load some words.'; return;
      }
      isDictating = true;
      renderWordTags(words);
      document.getElementById('status').textContent = 'Starting dictation...';
      updateProgress(); nextWord();
    }

    function toggleWord() {
      showRealWord = !showRealWord;
      updateWordDisplay();
    }

    function updateWordDisplay() {
      const wordDisplay = document.getElementById('wordDisplay');
      if (index > 0 && index <= words.length) {
        const word = showRealWord ? words[index - 1] : '***';
        wordDisplay.innerHTML = `Answer Key: ${word} <button class="eye-btn" onclick="toggleWord()">🙈</button>`;
      } else {
        wordDisplay.innerHTML = 'Answer Key: *** <button class="eye-btn" onclick="toggleWord()">👁️</button>';
      }
    }

    function toggleHint() {
      hintsVisible = !hintsVisible;
      const hintBox = document.getElementById('hintBox');
      const hintBtn = document.getElementById('hintBtn');
      if (hintsVisible) {
        hintBtn.textContent = 'Hide Hints';
        showHint();
      } else {
        hintBtn.textContent = 'Show Hints';
        hintBox.textContent = 'Click the Show Hint button to reveal a hint for the current word.';
      }
    }

    async function showHint() {
      if (index === 0 || index > words.length) return;
      const word = words[index - 1];
      const hintBox = document.getElementById('hintBox');

      if(hintsVisible){
        try {
          const [chRes, enRes] = await Promise.all([
            fetch(`http://127.0.0.1:3000/api/chinese?word=${encodeURIComponent(word)}`),
            fetch(`http://127.0.0.1:3000/api/english?word=${encodeURIComponent(word)}`)
          ]);
          const chinese = await chRes.json();
          const english = await enRes.json();
        hintBox.textContent =  `${chinese.chinese}\n${english.definition}`;
        } catch (e) {
          hintBox.textContent = 'Failed to load Chinese translation.';
        }
      }
      else{
        hintBox.textContent = 'Click the Show Hint button to reveal a hint for the current word.';
      }
    }

    function renderWordTags(list) {
      const box = document.getElementById('wordTags');
      if (!box) return;
      box.innerHTML = '';
      list.forEach((w, i) => {
        const s = document.createElement('span');
        s.className = 'tag';
        s.dataset.idx = i;          // <-- key: tie tags to word index
        s.textContent = w;
        box.appendChild(s);
      });
    }


    // --- Reset all UI/state when switching modes ---
    function resetUI({ clearInput = true } = {}) {
      // stop any speech + listening
      try { speechSynthesis.cancel(); } catch {}
      if (recognition && recognitionActive) {
        try { recognition.stop(); } catch {}
      }
      clearTimeout(listenRetryTimer); listenRetryTimer = null;

      // reset state
      isDictating = false;
      words = [];
      index = 0;
      wentBack = false;

      // clear UI
      const statusEl = document.getElementById('status');
      if (statusEl) statusEl.textContent = 'Status: Waiting for input...';

      const progEl = document.getElementById('progress');
      if (progEl) progEl.textContent = '';

      const tagsBox = document.getElementById('wordTags');
      if (tagsBox) tagsBox.innerHTML = '';

      const answerKey = document.getElementById('answerKey');            // optional element
      if (answerKey) answerKey.innerHTML = '';
      const answerKeySection = document.getElementById('answerKeySection'); // optional section
      if (answerKeySection) answerKeySection.style.display = 'none';

      if (clearInput) {
        const input = document.getElementById('wordInput');
        if (input) input.value = '';
      }

      const ribbons = document.getElementById('ribbons');
      if (ribbons) ribbons.style.display = 'none';
    }
    function resetUI({ clearInput = true, clearSelectors = false } = {}) {
      try { speechSynthesis.cancel(); } catch {}
      if (recognition && recognitionActive) { try { recognition.stop(); } catch {} }
      clearTimeout(listenRetryTimer); listenRetryTimer = null;

      // core state
      isDictating = false;
      words = [];
      index = 0;
      wentBack = false;

      // UI bits
      const statusEl = document.getElementById('status');
      if (statusEl) statusEl.textContent = 'Status: Waiting for input...';
      const progEl = document.getElementById('progress');
      if (progEl) progEl.textContent = '';

      const tagsBox = document.getElementById('wordTags');
      if (tagsBox) tagsBox.innerHTML = '';

      const ribbons = document.getElementById('ribbons');
      if (ribbons) ribbons.style.display = 'none';

      // optional: your answer key section if present
      const answerKey = document.getElementById('answerKey');
      if (answerKey) answerKey.innerHTML = '';
      const answerKeySection = document.getElementById('answerKeySection');
      if (answerKeySection) answerKeySection.style.display = 'none';

      if (clearInput) {
        const input = document.getElementById('wordInput');
        if (input) input.value = '';
      }

      if (clearSelectors) {
        const bookSel = document.getElementById('bookSelect');
        const sheetSel = document.getElementById('sheetSelect');
        if (bookSel) bookSel.selectedIndex = -1;
        if (sheetSel) { sheetSel.innerHTML = ''; sheetSel.selectedIndex = -1; }
      }
    }

    function setActiveTag(i) {
      const box = document.getElementById('wordTags');
      if (!box) return;
      const prev = box.querySelector('.tag.active');
      if (prev) prev.classList.remove('active');
      const cur = box.querySelector(`.tag[data-idx="${i}"]`);
      if (cur) {
        cur.classList.add('active');
        // keep the active tag in view
        cur.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
      }
    }

    document.getElementById('startBtn').onclick = startDictation;
     </script>
</body>
</html>

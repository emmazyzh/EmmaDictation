<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Dictation Practice Tool</title>
  <style>
  /* =========================
    Tokens & Base
  ========================= */
  :root{
    --page-max: 960px;
    --panel-max: 900px; 
    --pad-x: clamp(12px, 4vw, 24px);
    --gap: clamp(8px, 2.5vw, 16px);
    --section-to-controls-gap: clamp(16px, 4vw, 36px);
  }

  body{
    font-family: system-ui,-apple-system,Segoe UI,Roboto,Helvetica Neue,Arial,"Noto Sans","PingFang SC","Hiragino Sans GB","Microsoft YaHei",sans-serif;
    text-align: center;
    padding: 2em;
    position: relative;
    overflow-x: hidden;
    background: #ffffff;
    color: #0f172a;
    font-size: clamp(14px, 1.5vw, 16px);
  }

  h1{
    font-size: clamp(1.25rem, 2.2vw + 1rem, 2rem);
    margin: 0 0 .25em;
  }

  .container{
    max-width: var(--page-max);
    margin: 0 auto;
    padding: 0 var(--pad-x);
    text-align: center;
  }

  .hidden{ display: none !important; }

  /* =========================
    Toolbar & Controls
  ========================= */
  .toolbar{
    display: flex;
    align-items: center;
    justify-content: center;
    gap: var(--gap);
    flex-wrap: wrap;
    margin: 0 auto 1rem;
  }

  .voice-toggle{ position: static; }

  .controls{
    display: grid;
    grid-template-columns: 1fr;
    gap: var(--gap);
    max-width: 720px;
    margin: 0 auto var(--gap);
  }

  /* =========================
    Buttons & Status
  ========================= */
  .icon-btn{
    font-size: 0.9em;
    padding: 0.7em 1.5em;
    margin: 0.3em;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    background-color: #2563eb;
    color: #fff;
    box-shadow: 0 1px 2px rgba(15,23,42,.08);
    transition: transform .06s ease, filter .12s ease;
    width: 100%;
  }
  .icon-btn:hover{ filter: brightness(1.05); }
  .icon-btn:active{ transform: translateY(1px) scale(.98); }

  #status, #progress{
    margin-top: 1em;
    font-size: 0.8em;
    color: #6b7280;
  }

  /* =========================
    Mode Pills (Radio)
  ========================= */
  /* Group shell */
  .mode-group{
    display: flex;
    width: fit-content;
    margin: 0 auto;
    gap: 6px;
    padding: 6px;
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    background: #f3f4f6;
  }

  /* Visually hide native radio */
  .mode-group label > input[type="radio"]{
    position: absolute !important;
    clip: rect(1px,1px,1px,1px);
    clip-path: inset(50%);
    width: 1px; height: 1px;
    overflow: hidden; white-space: nowrap;
  }

  /* Label as button */
  .mode-group label{
    position: relative;
    cursor: pointer;
    padding: 8px 14px;
    border-radius: 10px;
    font-size: 14px;
    font-weight: 600;
    color: #374151;
    user-select: none;
    transition: background .15s ease, color .15s ease, box-shadow .2s ease, transform .06s ease;
  }
  .mode-group label:hover{ background: #eef2ff; }

  /* Selected */
  .mode-group label:has(input:checked){
    background: #ffffff;
    color: #111827;
    box-shadow: 0 1px 2px rgba(0,0,0,.06);
  }

  /* Keyboard focus */
  .mode-group label:has(input:focus-visible){
    outline: 2px solid #93c5fd;
    outline-offset: 2px;
  }

  /* =========================
    Inputs & Hints
  ========================= */
  textarea,
  #hintContainer,
  .tags-section{
    width: 100%;
    margin-left: auto;
    margin-right: auto;
    font-size: 0.9em;
  }

  textarea{
    height: clamp(120px, 22vh, 200px);
    font-size: 0.8em;
    padding: 0.5em;
    margin: 2em 0;
    background:#fff;
    border:1px solid #e5e7eb;
    border-radius:10px;
  }

  #hintContainer{ text-align: left; }
  #hintTitle{
    font-weight: bold;
    margin-bottom: 0.5em;
    font-size: 0.9em;
  }
  #hintBox{
    border: 1px solid #e5e7eb;
    padding: 1em;
    border-radius: 12px;
    background: #f9fafb;
    white-space: pre-wrap;
    font-size: clamp(13px, 1.6vw, 14px);
    overflow-wrap: anywhere;
  }

  /* =========================
    Tags
  ========================= */
  .tags-section{ margin: 32px auto 40px; }
  .tags-title{ font-size: 16px; margin: 0 0 10px; color: #6b7280; }
  .tags-wrap{
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    justify-content: center;
  }
  .tag{
    display: inline-block;
    padding: .5em .9em;
    border-radius: 999px;
    border: 1px solid #e5e7eb;
    background: #f3f4f6;
    color: #0f172a;
    font-size: clamp(12px, 2.5vw, 14px);
    transition: transform .08s ease, box-shadow .15s ease, background .15s ease;
  }
  .tag:hover{ transform: translateY(-1px); box-shadow: 0 2px 6px rgba(0,0,0,.06); }
  .tag.active{
    background: #e0ecff;
    border-color: #3b82f6;
    outline: 2px solid #93c5fd;
    transform: scale(1.03);
  }

  /* =========================
    Word Display
  ========================= */
  #wordDisplay{
    font-weight: bold;
    font-size: clamp(1rem, 2.5vw, 1.2rem);
    margin: 1em 0;
  }
  .eye-btn{
    background: none;
    border: none;
    cursor: pointer;
    font-size: clamp(1rem, 4vw, 1.2rem);
    margin-left: 0.5em;
  }

  /* =========================
    Panels: Book & Custom
  ========================= */
  /* Unified panel sizing */
  #bookSection,
  #customSection{
    width: 100%;
    max-width: var(--panel-max);
    --panel-h: clamp(220px, 38vh, 420px);
    min-height: var(--panel-h);
    margin-bottom: var(--section-to-controls-gap);
  }

  /* Book: two-column grid on wide screens */
  #bookSection{
    display: grid;
    grid-template-columns: repeat(2, minmax(280px, 1fr));
    gap: 12px;
    max-width: 900px;
    margin-left: auto;
    margin-right: auto;
    width: 100%;
  }

  /* Generic multi/select visuals */
  select[multiple],
  select[size]{
    width: 100%;
    padding: 0.5em;
    background:#fff;
    border:1px solid #e5e7eb;
    border-radius:10px;
    height: clamp(140px, 38vh, 320px);
  }

  /* Force selects to fill Book panel height */
  #bookSection select{
    width: 100% !important;
    max-width: 100%;
    height: 100% !important;
    min-height: 0;
  }

  /* Custom: textarea fills the panel */
  #customSection{
    display: grid;
  }
  #customSection textarea{
    width: 100% !important;
    max-width: 100%;
    height: 100% !important;
    margin: 0;
    box-sizing: border-box;
  }

  /* =========================
    Confetti Overlay
  ========================= */
  #ribbons{
    display: none;
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    pointer-events: none;
    z-index: 9999;
    background: url('https://www.gifcen.com/wp-content/uploads/2022/06/confetti-gif-3.gif') repeat;
    background-size: 240px auto;
  }

  /* Allow long content to break */
  #wordTags{ overflow-wrap: anywhere; }

  /* =========================
    Responsive
  ========================= */
  @media (min-width: 640px){
    .controls{ grid-template-columns: repeat(2, minmax(0,1fr)); }
  }
  @media (min-width: 900px){
    .controls{ grid-template-columns: repeat(4, minmax(0,1fr)); }
  }
  @media (max-width: 900px){
    #bookSection{ grid-template-columns: 1fr; }
  }


  </style>

  <script src="https://kit.fontawesome.com/a076d05399.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>

  
</head>
<body>
  <div class="container">
    <h1>Dictation Tool</h1>
    <div class="toolbar">
      <div class="mode-group">
        <label><input type="radio" name="mode" value="book"> Choose a Book</label>
        <label><input type="radio" name="mode" value="custom" checked> Customize Your Own Vocabulary List</label>
      </div>

      <div class="voice-toggle hidden">
        <label for="voiceSelect">Voice:</label>
        <select id="voiceSelect">
          <option value="Evan">Evan</option>
          <option value="Tom">Tom</option>
          <option value="Samantha">Samantha</option>
          <option value="Zoe">Zoe</option>
        </select>
      </div>
    </div>
    <div id="bookSection" class="hidden">
      <select id="bookSelect" size="10"></select>
      <select id="sheetSelect" size="10"></select>
    </div>

    <div id="customSection">
      <textarea id="wordInput" placeholder="e.g., apple, banana, chocolate"></textarea>
    </div>
    <div class="controls">
      <button id="startBtn" class="icon-btn">Start</button>
      <button onclick="nextWord()" class="icon-btn">Next</button>
      <!--button onclick="playPreviousWord()" class="icon-btn">Last</!--button-->
      <button onclick="repeatCurrentWord()" class="icon-btn">Repeat</button>
      <button id="hintBtn" onclick="toggleHint()" class="icon-btn">Show Hint</button>
    </div>

    <div id="wordDisplay">Answer Key: *** <button class="eye-btn" onclick="toggleWord()">üëÅÔ∏è</button></div>
    <p><span id="progress"></span>&nbsp;&nbsp;&nbsp;<span id="status">Status: Waiting for input...</span></p>

    <div id="hintContainer">
      <div id="hintTitle">Hints:</div>
      <div id="hintBox">Click the Show Hint button to reveal a hint for the current word.</div>
    </div>
    <section id="word-tags-section" class="tags-section">
        <div id="wordTags" class="tags-wrap"></div>
    </section>
  </div>

  <div id="ribbons"></div>

  <script>
    const books = {
      "BJU Science": "http://localhost:3000/download?id=1w12b1K3riu1T_ksH6OH_D2zCHr1bitTM"
    };

    let words = [], index = 0, voices = [], selectedVoice = null, isDictating = false, wentBack = false, showRealWord = false, hintsVisible = false;
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    let recognition = null;          // Â§çÁî®Âêå‰∏Ä‰∏™ÂÆû‰æã
    let recognitionActive = false;   // ÊòØÂê¶Â§Ñ‰∫éonstart~onend‰πãÈó¥
    let listenRetryTimer = null;     // ÈáçËØïÂÆöÊó∂Âô®

    document.querySelectorAll('input[name="mode"]').forEach(r => {
      r.addEventListener('change', (e) => {
        if (e.target.value === 'book') {
          resetUI({ clearInput: true, clearSelectors: true });
          document.getElementById('bookSection').classList.remove('hidden');
          document.getElementById('customSection').classList.add('hidden');
          document.getElementById('bookSelect').selectedIndex = 0;
          document.getElementById('bookSelect').dispatchEvent(new Event('change'));
        } else {
          resetUI({ clearInput: true, clearSelectors: true });
          document.getElementById('customSection').classList.remove('hidden');
          document.getElementById('bookSection').classList.add('hidden');
        }
      });
    });

    window.onload = () => {
      const bookSelect = document.getElementById('bookSelect');
      for (const bookName in books) {
        const opt = document.createElement('option');
        opt.value = bookName;
        opt.textContent = bookName;
        bookSelect.appendChild(opt);
      }
      bookSelect.selectedIndex = 0;
    };

    document.getElementById('bookSelect').addEventListener('change', async () => {
      const url = books[document.getElementById('bookSelect').value];
      try {
        const response = await fetch(url);
        const arrayBuffer = await response.arrayBuffer();
        const workbook = XLSX.read(arrayBuffer, { type: 'array' });
        const sheetSelect = document.getElementById('sheetSelect');
        sheetSelect.innerHTML = '';

        const displayMap = workbook.SheetNames.map(name => {
          const trimmed = name.trim();
          const match = trimmed.match(/^(\d+)-(\d+)$/);
          const display = match ? `Grade ${match[1]} Unit ${match[2]}` : trimmed;
          return { value: name, label: display };
        }).sort((a, b) => a.label.localeCompare(b.label));

        displayMap.forEach(({ value, label }) => {
          const opt = document.createElement('option');
          opt.value = value;
          opt.textContent = label;
          sheetSelect.appendChild(opt);
        });

        sheetSelect.selectedIndex = 0;
        await preloadSheetWords();
      } catch (error) {
        console.error('Error loading workbook:', error);
      }
    });

    document.getElementById('sheetSelect').addEventListener('change', preloadSheetWords);

    async function preloadSheetWords() {
      const bookName = document.getElementById('bookSelect').value;
      const sheetSelect = document.getElementById('sheetSelect');
      const sheetName = sheetSelect.value;
      const selectedText = sheetSelect.options[sheetSelect.selectedIndex].textContent;
      const url = books[bookName];
      const response = await fetch(url);
      const arrayBuffer = await response.arrayBuffer();
      const workbook = XLSX.read(arrayBuffer, { type: 'array' });
      const sheet = workbook.Sheets[sheetName];
      const data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
      words = data.slice(1).map(row => row[1]).filter(Boolean);
      index = 0;
      updateProgress();
      renderWordTags(words);
      document.getElementById('status').textContent = `${selectedText}: ${words.length} words loaded. Ready to start.`;
    }

    // ---------- Voice mapping: keep 4 labels, map to real voices ----------

    const LABEL_PREFS = {
      Tom: {
        langPref: ['en-GB','en-US'],
        candidates: ['Tom','Daniel','Alex','Google UK English Male','Google US English','Microsoft David','Microsoft Mark']
      },
      Evan: {
        langPref: ['en-US','en-GB'],
        candidates: ['Evan','Alex','Daniel','Google US English','Microsoft David','Microsoft Mark']
      },
      Samantha: {
        langPref: ['en-US','en-GB'],
        candidates: ['Samantha','Victoria','Jenny','Aria','Zira','Google US English','Google UK English Female','Microsoft Zira']
      },
      Zoe: {
        langPref: ['en-GB','en-US'],
        candidates: ['Zoe','Kate','Serena','Google UK English Female','Google US English','Microsoft Zira']
      }
    };

    function refreshVoices(){
      voices = speechSynthesis.getVoices() || [];
    }

    function pickByCandidates(candidates, list){
      if (!list.length) return null;
      // 1) exact
      let v = list.find(x => candidates.includes(x.name));
      if (v) return v;
      // 2) substring fuzzy
      v = list.find(x => candidates.some(c => x.name.toLowerCase().includes(c.toLowerCase())));
      if (v) return v;
      return null;
    }

    function pickByLangPrefs(langPrefs, list){
      for (const lp of langPrefs){
        const byLang = list.filter(x => (x.lang || '').toLowerCase().startsWith(lp.toLowerCase()));
        if (byLang.length) return byLang[0];
      }
      // fallback: any English
      const en = list.find(x => /^en[-_]/i.test(x.lang || ''));
      if (en) return en;
      return list[0] || null;
    }

    function resolveVoice(label){
      refreshVoices();
      const pref = LABEL_PREFS[label] || LABEL_PREFS.Samantha;
      // ‰ºòÂÖàÔºöËã±ËØ≠ËØ≠Èü≥ÂàóË°®
      const english = voices.filter(v => /^en[-_]/i.test(v.lang || ''));
      // ÂÖàÊåâÂÄôÈÄâÂêçÂåπÈÖç
      let v = pickByCandidates(pref.candidates, english);
      if (v) return v;
      v = pickByCandidates(pref.candidates, voices);
      if (v) return v;
      // ÂÜçÊåâËØ≠Ë®ÄÂÅèÂ•Ω
      v = pickByLangPrefs(pref.langPref, english.length ? english : voices);
      return v;
    }

    // ÂàùÂßãÂåñ‰∏é‰∫ã‰ª∂
    function initVoiceSelectBinding(){
      const sel = document.getElementById('voiceSelect');
      if (!sel) return;

      // È¶ñÊ¨°Âà∑Êñ∞ & ÂÖºÂÆπ Chrome ÂºÇÊ≠•Âä†ËΩΩ
      refreshVoices();
      if (!voices.length){
        setTimeout(() => { refreshVoices(); if (!selectedVoice) updateSelectedFromUI(); }, 200);
      }

      // ÈÄâÈ°πÊîπÂèòÊó∂ÔºåÊåâÊ†áÁ≠æÊò†Â∞ÑÂà∞ÁúüÂÆû voice
      sel.addEventListener('change', updateSelectedFromUI);

      // È°µÈù¢ËΩΩÂÖ•Êó∂Ê†πÊçÆÂΩìÂâç‰∏ãÊãâÂÄºËÆæÁΩÆ‰∏ÄÊ¨°
      updateSelectedFromUI();
    }

    function updateSelectedFromUI(){
      const sel = document.getElementById('voiceSelect');
      if (!sel) return;
      selectedVoice = resolveVoice(sel.value) || null;
      // ÂèØÈÄâÔºöÊèêÁ§∫ÂΩìÂâçÁúüÂÆû‰ΩøÁî®ÁöÑ voice ÂêçÁß∞
      // document.getElementById('status').textContent = `Using voice: ${selectedVoice?.name || 'default'}`;
    }

    // Chrome ‰ºöÂú® voices Â∞±Áª™Êó∂Ëß¶Âèë
    speechSynthesis.onvoiceschanged = () => {
      refreshVoices();
      updateSelectedFromUI();
    };
    
    function speakText(text) {
      // Êí≠Êä•ÂâçÔºöËã•Ê≠£Âú®Âê¨ÔºåÂàôÂÖàÂÅúÔºà‰∏ç‰ºöËß¶ÂèëËá¥ÂëΩÈîôËØØÔºâ
      if (recognition && recognitionActive) {
        try { recognition.stop(); } catch {}
      }

      const u = new SpeechSynthesisUtterance(text);
      // Prefer the selected voice‚Äôs language if present
      if (selectedVoice) {
        u.voice = selectedVoice;                // <-- critical
        u.lang  = selectedVoice.lang || 'en-US';
      } else {
        u.lang  = 'en-US';
      }
      // u.voice = selectedVoice; // Ëã•‰Ω†ÊúâËá™ÂÆö‰πâÂ£∞Èü≥
      u.onend = () => {
        // ËØ¥ÂÆåÂÜçËøõÁõëÂê¨ÔºåÈÅøÂÖçËá™ËØ¥Ëá™Âê¨ÈÄ†Êàê aborted
        listenNextCommand();
      };
      speechSynthesis.speak(u);
    }

    // È°µÈù¢Âä†ËΩΩÂêéÁªëÂÆö‰∏ÄÊ¨°
    window.addEventListener('load', initVoiceSelectBinding);

    function updateProgress() {
      document.getElementById('progress').textContent = `Progress: ${Math.min(index, words.length)} / ${words.length}`;
    }


    function showRibbons() {
      console.log("showRibbons triggered");
      const ribbonDiv = document.getElementById('ribbons');
      ribbonDiv.style.display = 'block';
      setTimeout(() => {
      ribbonDiv.style.display = 'none';
      }, 5000);
    }


    function listenNextCommand() {
      if (!SR) {
        document.getElementById('status').textContent =
          'SpeechRecognition not supported in this browser.';
        return;
      }

      // ÂàùÂßãÂåñ & ‰ªÖÁªëÂÆö‰∏ÄÊ¨°‰∫ã‰ª∂
      if (!recognition) {
        recognition = new SR();
        recognition.lang = 'en-US';
        recognition.interimResults = false;
        recognition.maxAlternatives = 1;

        recognition.onstart = () => { recognitionActive = true; };
        recognition.onend   = () => { recognitionActive = false; };

        recognition.onresult = (event) => {
          const transcript = (event.results?.[0]?.[0]?.transcript || '')
            .toLowerCase();
          document.getElementById('status').textContent = `Heard: "${transcript}"`;

          if (transcript.includes("next") || transcript.includes("move on")
              || transcript.includes("done") || transcript.includes("finished")
              || transcript.includes("completed")) {

            if (index >= words.length) {
              // ÂèØÈÄâÔºöËØ¥ËØùÂâçÂÅúÊ≠¢È∫¶ÂÖãÈ£éÔºåÈÅøÂÖçËá™ËØ¥Ëá™Âê¨
              if (recognitionActive) { try { recognition.stop(); } catch {} }
              speakText('Great job! You finished the dictation! See you next time.');
              document.getElementById('status').textContent =
                'Great job! You finished the dictation! See you next time.';
              showRibbons();
              return;
            }
            nextWord(); // Âª∫ËÆÆÂú® nextWord ÁöÑÊí≠Êä•ÁªìÊùüÂêéÂÜçË∞ÉÁî® listenNextCommand()
            return;

          } else if (transcript.includes("again") || transcript.includes("repeat")
                    || transcript.includes("pardon")) {
            repeatCurrentWord(); // Âêå‰∏äÔºåÊí≠Êä•ÁªìÊùüÂêéÂÜçËøõÂÖ•ÁõëÂê¨
            return;

          } else if (transcript.includes("last") || transcript.includes("previous")
                    || transcript.includes("back")) {
            playPreviousWord(); // Âêå‰∏ä
            return;
          }

          // Êú™ËØÜÂà´Âà∞ÂëΩ‰ª§ÔºöÁ®çÂêéÂÜçÂê¨‰∏ÄÊ¨°ÔºàÈÅøÂÖçÁ´ãÂàª start ÂØºËá¥Á´û‰∫âÔºâ
          scheduleStart(180);
        };

        recognition.onerror = (event) => {
          const err = String(event?.error || '').toLowerCase();
          // "aborted" Â§ö‰∏∫ÈùûËá¥ÂëΩÔºàstop/ÂàáÊç¢ÂØºËá¥ÔºâÔºåÂøΩÁï•Âç≥ÂèØ
          if (err !== 'aborted') {
            document.getElementById('status').textContent = `Error: ${event.error}`;
          }
          // Ëã•‰ªçÈúÄÁªßÁª≠Âê¨ÂëΩ‰ª§ÔºåÁ®çÂêéÂÜçÂ∞ùËØïÂêØÂä®
          scheduleStart(220);
        };
      }

      // ÂÆâÂÖ®Âú∞ÂêØÂä®ËØÜÂà´Ôºö‰∏çÂú®TTSËØ¥ËØùÊó∂„ÄÅ‰∏çÂú®Â∑≤ÊøÄÊ¥ªÊó∂
      scheduleStart(0);

      function scheduleStart(delayMs) {
        clearTimeout(listenRetryTimer);
        listenRetryTimer = setTimeout(() => {
          // TTS Âú®ËØ¥ËØùÂ∞±Âª∂Âêé
          if (speechSynthesis.speaking) { scheduleStart(150); return; }
          // Â∑≤Âú®ÁõëÂê¨‰∏≠Â∞±‰∏çÈáçÂ§ç start
          if (recognitionActive) return;
          try {
            recognition.start();
          } catch (e) {
            // ÂèØËÉΩÊòØ invalid_stateÔºöÂÜçÁ≠â‰∏Ä‰∏ãÈáçËØï
            scheduleStart(200);
          }
        }, delayMs);
      }
    }

    function repeatCurrentWord() {
      if (index > 0 && index <= words.length) {
        setActiveTag(index - 1);           // keep highlight on the same word
        speakText(words[index - 1]);
      }
      setTimeout(() => listenNextCommand(), 1000);
    }

    function playPreviousWord() {
      if (index <= 1 || wentBack) { listenNextCommand(); return; }
      index -= 2; wentBack = true; nextWord();
    }

    function nextWord() {
      if (!isDictating) return;
      if (index < words.length) {
        wentBack = false;
        document.getElementById('status').textContent = ``;

        // highlight the tag for the word we're about to speak
        setActiveTag(index);

        const currentWord = words[index++];
        speakText(currentWord);
        updateProgress();
        updateWordDisplay();
        showHint();
        setTimeout(() => listenNextCommand(), 1000);
      } else {
        document.getElementById('status').textContent = 'Great job! You finished the dictation! See you next time.';
        speakText('Great job! You finished the dictation! See you next time.');
        showRibbons(); updateProgress(); isDictating = false;
      }
    }


    function startDictation() {
      const mode = document.querySelector('input[name="mode"]:checked').value;
      if (mode === 'custom') {
        words = document.getElementById('wordInput').value.split(/\r?\n|,/).map(w => w.trim()).filter(Boolean);
      }
      const sel = document.getElementById('voiceSelect');
      const v = sel ? pickVoiceByName(sel.value) : null;
      selectedVoice = isVoiceValid(v) ? v : null; // Êâæ‰∏çÂà∞Â∞±ËÆ©ÂÆÉ‰∏∫ null
      index = 0; wentBack = false;
      if (words.length === 0) {
        document.getElementById('status').textContent = 'Please enter or load some words.'; return;
      }
      isDictating = true;
      renderWordTags(words);
      document.getElementById('status').textContent = 'Starting dictation...';
      updateProgress(); nextWord();
    }

    function toggleWord() {
      showRealWord = !showRealWord;
      updateWordDisplay();
    }

    function updateWordDisplay() {
      const wordDisplay = document.getElementById('wordDisplay');
      if (index > 0 && index <= words.length) {
        const word = showRealWord ? words[index - 1] : '***';
        wordDisplay.innerHTML = `Answer Key: ${word} <button class="eye-btn" onclick="toggleWord()">üôà</button>`;
      } else {
        wordDisplay.innerHTML = 'Answer Key: *** <button class="eye-btn" onclick="toggleWord()">üëÅÔ∏è</button>';
      }
    }

    function toggleHint() {
      hintsVisible = !hintsVisible;
      const hintBox = document.getElementById('hintBox');
      const hintBtn = document.getElementById('hintBtn');
      if (hintsVisible) {
        hintBtn.textContent = 'Hide Hints';
        showHint();
      } else {
        hintBtn.textContent = 'Show Hints';
        hintBox.textContent = 'Click the Show Hint button to reveal a hint for the current word.';
      }
    }

    async function showHint() {
      if (index === 0 || index > words.length) return;
      const word = words[index - 1];
      const hintBox = document.getElementById('hintBox');

      if(hintsVisible){
        try {
          const [chRes, enRes] = await Promise.all([
            fetch(`http://127.0.0.1:3000/api/chinese?word=${encodeURIComponent(word)}`),
            fetch(`http://127.0.0.1:3000/api/english?word=${encodeURIComponent(word)}`)
          ]);
          const chinese = await chRes.json();
          const english = await enRes.json();
        hintBox.textContent =  `${chinese.chinese}\n${english.definition}`;
        } catch (e) {
          hintBox.textContent = 'Failed to load Chinese translation.';
        }
      }
      else{
        hintBox.textContent = 'Click the Show Hint button to reveal a hint for the current word.';
      }
    }

    function renderWordTags(list) {
      const box = document.getElementById('wordTags');
      if (!box) return;
      box.innerHTML = '';
      list.forEach((w, i) => {
        const s = document.createElement('span');
        s.className = 'tag';
        s.dataset.idx = i;          // <-- key: tie tags to word index
        s.textContent = w;
        box.appendChild(s);
      });
    }


    // --- Reset all UI/state when switching modes ---
    function resetUI({ clearInput = true } = {}) {
      // stop any speech + listening
      try { speechSynthesis.cancel(); } catch {}
      if (recognition && recognitionActive) {
        try { recognition.stop(); } catch {}
      }
      clearTimeout(listenRetryTimer); listenRetryTimer = null;

      // reset state
      isDictating = false;
      words = [];
      index = 0;
      wentBack = false;

      // clear UI
      const statusEl = document.getElementById('status');
      if (statusEl) statusEl.textContent = 'Status: Waiting for input...';

      const progEl = document.getElementById('progress');
      if (progEl) progEl.textContent = '';

      const tagsBox = document.getElementById('wordTags');
      if (tagsBox) tagsBox.innerHTML = '';

      const answerKey = document.getElementById('answerKey');            // optional element
      if (answerKey) answerKey.innerHTML = '';
      const answerKeySection = document.getElementById('answerKeySection'); // optional section
      if (answerKeySection) answerKeySection.style.display = 'none';

      if (clearInput) {
        const input = document.getElementById('wordInput');
        if (input) input.value = '';
      }

      const ribbons = document.getElementById('ribbons');
      if (ribbons) ribbons.style.display = 'none';
    }
    function resetUI({ clearInput = true, clearSelectors = false } = {}) {
      try { speechSynthesis.cancel(); } catch {}
      if (recognition && recognitionActive) { try { recognition.stop(); } catch {} }
      clearTimeout(listenRetryTimer); listenRetryTimer = null;

      // core state
      isDictating = false;
      words = [];
      index = 0;
      wentBack = false;

      // UI bits
      const statusEl = document.getElementById('status');
      if (statusEl) statusEl.textContent = 'Status: Waiting for input...';
      const progEl = document.getElementById('progress');
      if (progEl) progEl.textContent = '';

      const tagsBox = document.getElementById('wordTags');
      if (tagsBox) tagsBox.innerHTML = '';

      const ribbons = document.getElementById('ribbons');
      if (ribbons) ribbons.style.display = 'none';

      // optional: your answer key section if present
      const answerKey = document.getElementById('answerKey');
      if (answerKey) answerKey.innerHTML = '';
      const answerKeySection = document.getElementById('answerKeySection');
      if (answerKeySection) answerKeySection.style.display = 'none';

      if (clearInput) {
        const input = document.getElementById('wordInput');
        if (input) input.value = '';
      }

      if (clearSelectors) {
        const bookSel = document.getElementById('bookSelect');
        const sheetSel = document.getElementById('sheetSelect');
        if (bookSel) bookSel.selectedIndex = -1;
        if (sheetSel) { sheetSel.innerHTML = ''; sheetSel.selectedIndex = -1; }
      }
    }

    function setActiveTag(i) {
      const box = document.getElementById('wordTags');
      if (!box) return;
      const prev = box.querySelector('.tag.active');
      if (prev) prev.classList.remove('active');
      const cur = box.querySelector(`.tag[data-idx="${i}"]`);
      if (cur) {
        cur.classList.add('active');
        // keep the active tag in view
        cur.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'center' });
      }
    }

    function pickClosestByLabel(label, list){
      // exact by name
      let v = list.find(x => x.name === label);
      if (v) return v;

      // fuzzy contains (case-insensitive)
      v = list.find(x => x.name.toLowerCase().includes(label.toLowerCase()));
      if (v) return v;

      // gender-ish heuristic (very rough; many voices don‚Äôt expose gender)
      if (/tom|evan/i.test(label)) {
        return list.find(x => /male|daniel|mark|alex/i.test(x.name)) || list[0] || null;
      }
      if (/zoe|samantha/i.test(label)) {
        return list.find(x => /female|samantha|zira|victoria|karen|moira/i.test(x.name)) || list[0] || null;
      }
      return list[0] || null;
    }

    // In your change handler, if you keep fixed options:
    const sel = document.getElementById('voiceSelect');
    sel?.addEventListener('change', () => {
      const voiceName = document.getElementById('voiceSelect').value;
      const v = pickVoiceByName(voiceName);
      selectedVoice = isVoiceValid(v) ? v : null; // null => ‰ΩøÁî®ÈªòËÆ§ËØ≠Èü≥
      if (selectedVoice) localStorage.setItem('voiceName', selectedVoice.name);
    });

    // ---- helpersÔºöÊ£ÄÊµã voice ÊòØÂê¶ÂèØÁî®ÔºåÊâæÂêåÂêç voice ----
    const IS_IOS = /iP(hone|ad|od)/.test(navigator.userAgent);

    function isVoiceValid(v){
      if (!v) return false;
      const list = speechSynthesis.getVoices() || [];
      return list.some(x =>
        x.voiceURI === v.voiceURI ||
        (x.name === v.name && x.lang === v.lang)
      );
    }

    function pickVoiceByName(name){
      const list = speechSynthesis.getVoices() || [];
      return list.find(x => x.name === name) || null;
    }


    document.getElementById('startBtn').onclick = startDictation;
    //document.querySelector('.voice-toggle')?.classList.add('hidden');    // hide

     </script>
</body>
</html>
